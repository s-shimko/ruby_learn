# --------------------  начало объявлений методов -----------------------

# Метод, очищающий экран. См. домашнее задание урока 6.
def cls
  system "clear" or system "cls"
end

# Метод, который возвращает массив букв загаданного слова
def get_letters
  # берем загаданное слово из командной строки
  slovo = ARGV[0]

  # Хитрое преобразование кодировок аргумента командной строки в нужную нам кодировку UTF-8.
  # Этот код будет выполнятся только на Windows, где есть сложности с кодировками.
  #
  # Здесь идет последовательный вызов нескольких методов и двойное преобразование кодировки.
  # Такая вот сложность есть с кодировками в консоли виндоус :) ПОка просто примите этот код на веру.
  #
  # ВНИМАНИЕ! Этот способ преобразования кодировок для Windows - немного отличается от того, что
  # мы показали на видео! 
  # Способ, показанный на видео тоже работает, но в некоторых версиях Windows может давать неверный результат. 
  #
  # Используйте код, приведенный в этом файле. 
  # Этот способ работает почти во всех разновидностях Windows 7+
  #
  if (Gem.win_platform? && ARGV[0])
    slovo = slovo.dup.force_encoding("IBM866").encode("IBM866", "cp1251").encode("UTF-8")
  end

  if (slovo == nil || slovo == "")
    abort "Для игры введите загаданное слово в качестве аргумента при запуске программы"
  end

  # возвращаем результат выполнения метода split(""),
  # встроенного в объект типа строка в руби. Этот метод разбивает строку на буквы.
  return slovo.split("")
end

# Метод, спрашивающий юзера букву и возвращающий ее как результат
def get_user_input
  letter = ""

  # в цикле будем опрашивать юзера, пока он не введет непустую строку
  while letter == "" do
    # вместо gets надо использовать STDIN.gets - особенность руби при
    # использования аргументов в командной строке (ARGV[0])
    letter = STDIN.gets.encode("UTF-8").chomp
  end

  return letter
end


# метод проверяющий введенную букву и заполняющий два массива - с "хорошими буквами",
# которые есть в слове, и "плохими" – которых в слове нет
# Метод возвращает 1, если всё слово угадано целиком. -1, если введенной буквы нет в слове
# и 0 - если буква есть в слове, но еще не все слово угадано
def check_input(user_input, letters, good_letters, bad_letters)

  # если введенная буква уже есть в списке "правильных" или "ошибочных" букв, вернем 0,
  # ничего не изменилось
  if good_letters.include?(user_input) || bad_letters.include?(user_input)
    return 0
  end

  # если в слове есть буква
  if letters.include?(user_input) ||
      (user_input == "е" && letters.include?("ё")) ||
      (user_input == "ё" && letters.include?("е"))


    good_letters << user_input # запишем её в число "правильных" буква

    if user_input == "е"
      good_letters << "ё"
    end

    if user_input == "ё"
      good_letters << "е"
    end


    # дополнительная проверка - угадано ли на этой букве все слово целиком
    # метод uniq возвращает массив, содержащий уникальные буквы, а sort сортирует их по порядку,
    # и если буквы в обоих массивах одинаковые, то их отсортированные списки совпадут и равенство
    # выполнится

    # Теперь старая проверка сработает неправильно! Потому что в список "хороших букв"
    # попадут буквы И и Й, Е и Ё, а исходное слово может содержать только И или только Е
    # if good_letters.uniq.sort == letters.uniq.sort - 

    #  Для првильной проверки используем возможность руби "вычитания" массивов
    #  Если мы из всех букв слова уберем все угаданные буквы, то останется массив, содержащий 
    #  буквы, которые еще не угаданы. Если этот массив пуст, значит мы угадали слово!
    if (letters - good_letters).empty?
      return 1
    else
      return 0
    end
  else # если в слове нет введенной буквы
    bad_letters << user_input # массив ошибочных букв пополняется новой буквой
    return -1 # возвращаем -1 как признак ошибки пользователя
  end
end

# Метод, возвращающий строку, изображающую загаданное слово
# с открытыми угаданными буквами
def get_word_for_print(letters, good_letters)
  result = ""

  for item in letters do # проходимся по буквам слова
    if good_letters.include?(item) # если эта буква слова есть в угаданных
      result += item + " " # будет отображена как есть
    else # если нету
      result += "__ " # вместо нее будет отображен прочерк
    end
  end

  return result
end

# Метод, выводящий на экран текущий статус игры
# В качестве входных параметром берется массив загаданного слова,
# массивы введенных угаданных и ошибочных букв, а также общее число сделанных ошибок
def print_status(letters, good_letters, bad_letters, errors)
  puts "\nСлово: #{get_word_for_print(letters, good_letters)}"

  puts "Ошибки (#{errors}): #{bad_letters.join(", ")}" # метод join возвращает "склеенный массив"

  if errors >= 7
    puts "Вы проиграли :("
  else
    # проверяем результат игры по уже готовым массивам правильных и ошибочных букв

    # Теперь старая проверка сработает неправильно! Потому что в список "хороших букв"
    # попадут буквы И и Й, Е и Ё, а исходное слово может содержать только И или только Е
    # if good_letters.uniq.sort == letters.uniq.sort - 

    #  Для првильной проверки используем возможность руби "вычитания" массивов
    #  Если мы из всех букв слова уберем все угаданные буквы, то останется массив, содержащий 
    #  буквы, которые еще не угаданы. Если этот массив пуст, значит мы угадали слово!
    if (letters - good_letters).empty?
      puts "Поздравляем, вы выиграли!\n\n"
    else
      puts "У вас осталось попыток: " + (7 - errors).to_s
    end
  end
end
# ------------------ конец объявлений методов ---------------------------